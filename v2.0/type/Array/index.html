<!DOCTYPE html>
<html>
  


  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    
    <title>Array &#8212; SwiftDoc.org</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Swift documentation for 'Array': Array is an efficient, tail-growable random-access collection of arbitrary elements.">
    <meta name="keywords" content="Array,struct,swift,documentation,reserveCapacity,append,appendContentsOf,appendContentsOf,removeLast,insert,removeAtIndex,removeAll,withUnsafeBufferPointer,withUnsafeMutableBufferPointer,replaceRange,popLast,startIndex,endIndex,count,capacity,description,debugDescription">
    <link rel="canonical" href="http://swiftdoc.org/v2.0/type/Array/">
    <link rel="Shortcut Icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="apple-touch-icon" href="/images/touch-icon-iphone.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/assets/images/touch-icon-ipad.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/assets/images/touch-icon-iphone-retina.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/assets/images/touch-icon-ipad-retina.png">
    <link rel="alternate" type="application/rss+xml" title="SwiftDoc.org" href="/feed.xml" />

    <meta property="og:site_name" content="SwiftDoc.org"/>
    <meta property="og:image" content="http://swiftdoc.org/assets/images/touch-icon-ipad-retina.png"/>
    <meta property="og:title" content="Array"/>
    <meta property="og:url" content="http://swiftdoc.org/v2.0/type/Array/index.html"/>
    <meta property="og:description" content="Swift documentation for 'Array': Array is an efficient, tail-growable random-access collection of arbitrary elements."/>

    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:site" content="@SwiftDocOrg"/>
    <meta name="twitter:creator" content="@SwiftDocOrg"/>
    <meta name="twitter:title" content="Array"/>
    <meta name="twitter:image" content="http://swiftdoc.org/assets/images/touch-icon-ipad-retina.png"/>
    <meta name="twitter:description" content="Swift documentation for &#39;Array&#39;: Array is an efficient, tail-growable random-access collection of arbitrary elements."/>
    <meta name="twitter:url" content="http://swiftdoc.org/v2.0/type/Array/index.html"/>

    <link href="/assets/swift-0d01cd7187823280d004769cfb0a49ed.css" rel="stylesheet" type="text/css" />
    <script src="/assets/swift-a93c7e66ac39404e15479229e3fbc78f.js" type="text/javascript"></script>

    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    
    <script src="/v2.0/assets/js/swift-linkdata.js"></script>
    
  </head>

  <body class="p-v2.0 p-type p-Array">
    <div id="wrapper">

        
	<nav class="navbar navbar-default" role="navigation" id="navbar">
      <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <h1><a href="/">SwiftDoc.org</a></h1>
          <span class="version"></span>
        </div>
	    <div class="collapse navbar-collapse navbar-ex1-collapse">
          <form class="navbar-form navbar-left" role="search">
          
    		<div class="form-group input-group has-feedback">
    			<input type="hidden" class="form-control select2">
    			<span class="glyphicon glyphicon-search form-control-feedback"></span>
    		</div>
            
          </form>
          <ul class="nav navbar-nav navbar-right">
              <li><a href="/type/">Types</a></li>
              <li><a href="/protocol/">Protocols</a></li>
              <li><a href="/operator/">Operators</a></li>
              <li><a href="/global/">Globals</a></li>
          </ul>
	    </div>
	</nav>				

	<div id="header">
		<div class="container">
			<h1><a href="/">SwiftDoc.org</a></h1>
			<p>Auto-generated documentation for <a href="https://developer.apple.com/swift/">Swift</a>. Command-click no more.</p>
			
			
		</div>
	</div>

    
    <div id="version">
		<div class="container">
    		
			Swift version: <a href="/v1.2/">1.2</a> &nbsp;|&nbsp; <strong>2.1</strong>
    		
		</div>
    </div>
    
    
	
    <div class="container">
      <div class="row">
        <div class="col-sm-4 col-md-3" id="sidebar">

    		<div class="form-group input-group has-feedback">
    			<input type="hidden" class="form-control select2">
    			<span class="glyphicon glyphicon-search form-control-feedback"></span>
    		</div>

            <div class="panel-group" id="accordion">

  <div class="panel">
    <div class="panel-heading">
      <h4 class="panel-title">
        <a data-toggle="collapse" data-parent="#accordion" href="#collapseTypes">
          Types
        </a>
      </h4>
    </div>
    <div id="collapseTypes" class="panel-collapse collapse">
      <div class="panel-body list-group">
      </div>
    </div>
  </div>

  <div class="panel">
    <div class="panel-heading">
      <h4 class="panel-title">
        <a data-toggle="collapse" data-parent="#accordion" href="#collapseProtocols">
          Protocols
        </a>
      </h4>
    </div>
    <div id="collapseProtocols" class="panel-collapse collapse">
      <div class="panel-body list-group">
      </div>
    </div>
  </div>

  <div class="panel">
    <div class="panel-heading">
      <h4 class="panel-title">
        <a data-toggle="collapse" data-parent="#accordion" href="#collapseOperators">
          Operators
        </a>
      </h4>
    </div>
    <div id="collapseOperators" class="panel-collapse collapse">
      <div class="panel-body list-group">
      </div>
    </div>
  </div>

  <div class="panel">
    <div class="panel-heading">
      <h4 class="panel-title">
        <a data-toggle="collapse" data-parent="#accordion" href="#collapseGlobals">
          Globals
        </a>
      </h4>
    </div>
    <div id="collapseGlobals" class="panel-collapse collapse">
      <div class="panel-body list-group">
      </div>
    </div>
  </div>

</div>

        </div>

        <div class="col-sm-8 col-md-9" id="content">
          <header>
            <h2>Array</h2>
          </header>
          
          <article class="content">
          <code class="language-swift">struct Array&lt;Element&gt; { ... }</code>

<div class="comment">
    <p><code>Array</code> is an efficient, tail-growable random-access
collection of arbitrary elements.</p>

<h1>Common Properties of Array Types</h1>

<p>The information in this section applies to all three of Swift&#39;s
array types, <code>Array&lt;Element&gt;</code>, <code>ContiguousArray&lt;Element&gt;</code>, and
<code>ArraySlice&lt;Element&gt;</code>.  When you read the word &quot;array&quot; here in
a normal typeface, it applies to all three of them.</p>

<h2>Value Semantics</h2>

<p>Each array variable, <code>let</code> binding, or stored property has an
independent value that includes the values of all of its elements.
Therefore, mutations to the array are not observable through its
copies:</p>

<pre><code class="language-swift">var a = [1, 2, 3]
var b = a
b[0] = 4
print(&quot;a=\(a), b=\(b)&quot;)     // a=[1, 2, 3], b=[4, 2, 3]</code></pre>

<p>(Of course, if the array stores <code>class</code> references, the objects
are shared; only the values of the references are independent.)</p>

<p>Arrays use Copy-on-Write so that their storage and elements are
only copied lazily, upon mutation, when more than one array
instance is using the same buffer.  Therefore, the first in any
sequence of mutating operations may cost <code>O(N)</code> time and space,
where <code>N</code> is the length of the array.</p>

<h2>Growth and Capacity</h2>

<p>When an array&#39;s contiguous storage fills up, new storage must be
allocated and elements must be moved to the new storage.  <code>Array</code>,
<code>ContiguousArray</code>, and <code>ArraySlice</code> share an exponential growth
strategy that makes <code>append</code> a constant time operation <em>when
amortized over many invocations</em>.  In addition to a <code>count</code>
property, these array types have a <code>capacity</code> that reflects their
potential to store elements without reallocation, and when you
know how many elements you&#39;ll store, you can call
<code>reserveCapacity</code> to pre-emptively reallocate and prevent
intermediate reallocations.</p>

<h1>Objective-C Bridge</h1>

<p>The main distinction between <code>Array</code> and the other array types is
that it interoperates seamlessly and efficiently with Objective-C.</p>

<p><code>Array&lt;Element&gt;</code> is considered bridged to Objective-C iff <code>Element</code>
is bridged to Objective-C.</p>

<p>When <code>Element</code> is a <code>class</code> or <code>@objc</code> protocol type, <code>Array</code> may
store its elements in an <code>NSArray</code>.  Since any arbitrary subclass
of <code>NSArray</code> can become an <code>Array</code>, there are no guarantees about
representation or efficiency in this case (see also
<code>ContiguousArray</code>).  Since <code>NSArray</code> is immutable, it is just as
though the storage was shared by some copy: the first in any
sequence of mutating operations causes elements to be copied into
unique, contiguous storage which may cost <code>O(N)</code> time and space,
where <code>N</code> is the length of the array (or more, if the underlying
<code>NSArray</code> is has unusual performance characteristics).</p>

<h2>Bridging to Objective-C</h2>

<p>Any bridged <code>Array</code> can be implicitly converted to an <code>NSArray</code>.
When <code>Element</code> is a <code>class</code> or <code>@objc</code> protocol, bridging takes O(1)
time and O(1) space.  Other <code>Array</code>s must be bridged
element-by-element, allocating a new object for each element, at a
cost of at least O(<code>count</code>) time and space.</p>

<h2>Bridging from Objective-C</h2>

<p>An <code>NSArray</code> can be implicitly or explicitly converted to any
bridged <code>Array&lt;Element&gt;</code>.  This conversion calls <code>copyWithZone</code>
on the <code>NSArray</code>, to ensure it won&#39;t be modified, and stores the
result in the <code>Array</code>.  Type-checking, to ensure the <code>NSArray</code>&#39;s
elements match or can be bridged to <code>Element</code>, is deferred until the
first element access.</p>
</div>

<h3>Inheritance</h3>
<code class="inherits">CollectionType, Indexable, SequenceType, MutableCollectionType, MutableIndexable, _DestructorSafeContainer, ArrayLiteralConvertible, _ArrayType, MutableSliceable, RangeReplaceableCollectionType, _Reflectable, CustomStringConvertible, CustomDebugStringConvertible</code>
<span class="viz"><a href="hierarchy/">Protocol hierarchy</a></span>




<h3>Initializers</h3>
<div class="declaration">
<code class="language-swift">init(arrayLiteral elements: Element...)</code>
<div class="comment">
    <p>Create an instance containing <code>elements</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init()</code>
<div class="comment">
    <p>Construct an empty Array.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init&lt;S : SequenceType where S.Generator.Element == _Buffer.Element&gt;(_ s: S)</code>
<div class="comment">
    <p>Construct from an arbitrary sequence with elements of type <code>Element</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(count: Int, repeatedValue: Element)</code>
<div class="comment">
    <p>Construct a Array of <code>count</code> elements, each initialized to
<code>repeatedValue</code>.</p>
</div>
</div>


<h3>Instance Variables</h3>
<div class="declaration" id="prop-startIndex">
<code class="language-swift">var startIndex: Int { get }</code>
<div class="comment">
    <p>Always zero, which is the index of the first element when non-empty.</p>
</div>
</div>
<div class="declaration" id="prop-endIndex">
<code class="language-swift">var endIndex: Int { get }</code>
<div class="comment">
    <p>A &quot;past-the-end&quot; element index; the successor of the last valid
subscript argument.</p>
</div>
</div>
<div class="declaration" id="prop-count">
<code class="language-swift">var count: Int { get }</code>
<div class="comment">
    <p>The number of elements the Array stores.</p>
</div>
</div>
<div class="declaration" id="prop-capacity">
<code class="language-swift">var capacity: Int { get }</code>
<div class="comment">
    <p>The number of elements the <code>Array</code> can store without reallocation.</p>
</div>
</div>
<div class="declaration" id="prop-description">
<code class="language-swift">var description: String { get }</code>
<div class="comment">
    <p>A textual representation of <code>self</code>.</p>
</div>
</div>
<div class="declaration" id="prop-debugDescription">
<code class="language-swift">var debugDescription: String { get }</code>
<div class="comment">
    <p>A textual representation of <code>self</code>, suitable for debugging.</p>
</div>
</div>


<h3>Instance Methods</h3>
<div class="declaration" id="func-reserveCapacity">
<code class="language-swift">mutating func reserveCapacity(minimumCapacity: Int) </code>
<div class="comment">
    <p>Reserve enough space to store <code>minimumCapacity</code> elements.</p>

<p><strong>Postcondition:</strong> <code>capacity &gt;= minimumCapacity</code> and the array has
  mutable contiguous storage.</p>

<p><strong>Complexity:</strong> O(<code>count</code>).</p>
</div>
</div>
<div class="declaration" id="func-append">
<code class="language-swift">mutating func append(newElement: Element) </code>
<div class="comment">
    <p>Append <code>newElement</code> to the Array.</p>

<p><strong>Complexity:</strong> Amortized O(1) unless <code>self</code>&#39;s storage is shared with another live array; O(<code>count</code>) if <code>self</code> does not wrap a bridged <code>NSArray</code>; otherwise the efficiency is unspecified..</p>
</div>
</div>
<div class="declaration" id="func-appendContentsOf">
<code class="language-swift">mutating func appendContentsOf&lt;S : SequenceType where S.Generator.Element == Element&gt;(newElements: S) </code>
<div class="comment">
    <p>Append the elements of <code>newElements</code> to <code>self</code>.</p>

<p><strong>Complexity:</strong> O(<em>length of result</em>).</p>
</div>
</div>
<div class="declaration" id="func-appendContentsOf">
<code class="language-swift">mutating func appendContentsOf&lt;C : CollectionType where C.Generator.Element == Element&gt;(newElements: C) </code>
<div class="comment">
    <p>Append the elements of <code>newElements</code> to <code>self</code>.</p>

<p><strong>Complexity:</strong> O(<em>length of result</em>).</p>
</div>
</div>
<div class="declaration" id="func-removeLast">
<code class="language-swift">mutating func removeLast() -> Element</code>
<div class="comment">
    <p>Remove an element from the end of the Array in O(1).</p>

<p><strong>Requires:</strong> <code>count &gt; 0</code>.</p>
</div>
</div>
<div class="declaration" id="func-insert">
<code class="language-swift">mutating func insert(newElement: Element, atIndex i: Int) </code>
<div class="comment">
    <p>Insert <code>newElement</code> at index <code>i</code>.</p>

<p><strong>Requires:</strong> <code>i &lt;= count</code>.</p>

<p><strong>Complexity:</strong> O(<code>count</code>).</p>
</div>
</div>
<div class="declaration" id="func-removeAtIndex">
<code class="language-swift">mutating func removeAtIndex(index: Int) -> Element</code>
<div class="comment">
    <p>Remove and return the element at index <code>i</code>.</p>

<p>Invalidates all indices with respect to <code>self</code>.</p>

<p><strong>Complexity:</strong> O(<code>count</code>).</p>
</div>
</div>
<div class="declaration" id="func-removeAll">
<code class="language-swift">mutating func removeAll(keepCapacity keepCapacity: Bool = default) </code>
<div class="comment">
    <p>Remove all elements.</p>

<p><strong>Postcondition:</strong> <code>capacity == 0</code> iff <code>keepCapacity</code> is <code>false</code>.</p>

<p><strong>Complexity:</strong> O(<code>self.count</code>).</p>
</div>
</div>
<div class="declaration" id="func-withUnsafeBufferPointer">
<code class="language-swift">func withUnsafeBufferPointer&lt;R&gt;(@noescape body: (UnsafeBufferPointer&lt;Element&gt;) throws -&gt; R) rethrows -> R</code>
<div class="comment">
    <p>Call <code>body(p)</code>, where <code>p</code> is a pointer to the <code>Array</code>&#39;s
contiguous storage. If no such storage exists, it is first created.</p>

<p>Often, the optimizer can eliminate bounds checks within an
array algorithm, but when that fails, invoking the
same algorithm on <code>body</code>&#39;s argument lets you trade safety for
speed.</p>
</div>
</div>
<div class="declaration" id="func-withUnsafeMutableBufferPointer">
<code class="language-swift">mutating func withUnsafeMutableBufferPointer&lt;R&gt;(@noescape body: (inout UnsafeMutableBufferPointer&lt;Element&gt;) throws -&gt; R) rethrows -> R</code>
<div class="comment">
    <p>Call <code>body(p)</code>, where <code>p</code> is a pointer to the <code>Array</code>&#39;s
mutable contiguous storage. If no such storage exists, it is first created.</p>

<p>Often, the optimizer can eliminate bounds- and uniqueness-checks
within an array algorithm, but when that fails, invoking the
same algorithm on <code>body</code>&#39;s argument lets you trade safety for
speed.</p>

<p><strong>Warning:</strong> Do not rely on anything about <code>self</code> (the <code>Array</code>
  that is the target of this method) during the execution of
  <code>body</code>: it may not appear to have its correct value.  Instead,
  use only the <code>UnsafeMutableBufferPointer</code> argument to <code>body</code>.</p>
</div>
</div>
<div class="declaration" id="func-replaceRange">
<code class="language-swift">mutating func replaceRange&lt;C : CollectionType where C.Generator.Element == _Buffer.Element&gt;(subRange: Range&lt;Int&gt;, with newElements: C) </code>
<div class="comment">
    <p>Replace the given <code>subRange</code> of elements with <code>newElements</code>.</p>

<p><strong>Complexity:</strong> O(<code>subRange.count</code>) if <code>subRange.endIndex
  == self.endIndex</code> and <code>newElements.isEmpty</code>, O(N) otherwise.</p>
</div>
</div>
<div class="declaration" id="func-popLast">
<code class="language-swift">mutating func popLast() -> Element?</code>
<div class="comment">
    <p>If <code>!self.isEmpty</code>, remove the last element and return it, otherwise
return <code>nil</code>.</p>

<p><strong>Complexity:</strong> O(<code>self.count</code>) if the array is bridged,
  otherwise O(1).</p>
</div>
</div>

<h3>Subscripts</h3>
<div class="declaration">
<code class="language-swift">subscript(index: Int) -> Element</code>
</div>
<div class="declaration">
<code class="language-swift">subscript(subRange: Range&lt;Int&gt;) -> ArraySlice&lt;Element&gt;</code>
</div>



          </article>

    
        </div><!-- content -->
      </div><!-- row -->
    </div><!-- cont -->
        <div class="push"></div>
    </div><!-- wrapper -->

            <div id="footer">
            <span class="line">
                <span class="version">Swift versions 602.0.49.3 & 700.1.101.6</span> &nbsp;&sdot;&nbsp;
                <a href="/news/">News</a>
            </span> <span class="sep">&nbsp;&sdot;&nbsp;</span>
            <span class="line">
                <a href="https://twitter.com/SwiftDocOrg">@SwiftDocOrg</a> &nbsp;&sdot;&nbsp;
                <a href="https://github.com/SwiftDocOrg">github.com/SwiftDocOrg</a>
            </span>
        </div>
        
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-58091972-1', 'auto');
  ga('send', 'pageview');
</script>

  
  </body>
</html>
