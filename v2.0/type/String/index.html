<!DOCTYPE html>
<html>
  


  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    
    <title>String &#8212; SwiftDoc.org</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Swift documentation for 'String': An arbitrary Unicode string value.">
    <meta name="keywords" content="String,struct,swift,documentation,withMutableCharacters,fromCString,fromCStringRepairingIllFormedUTF8,withCString,write,writeTo,appendContentsOf,append,reserveCapacity,append,appendContentsOf,replaceRange,replaceRange,insert,insertContentsOf,removeAtIndex,removeRange,removeAll,hasPrefix,hasSuffix,availableStringEncodings,defaultCStringEncoding,localizedNameOfStringEncoding,localizedStringWithFormat,canBeConvertedToEncoding,capitalizedStringWithLocale,caseInsensitiveCompare,commonPrefixWithString,compare,completePathIntoString,componentsSeparatedByCharactersInSet,componentsSeparatedByString,cStringUsingEncoding,dataUsingEncoding,enumerateLines,enumerateLinguisticTagsInRange,enumerateSubstringsInRange,getBytes,getCString,getLineStart,getParagraphStart,lengthOfBytesUsingEncoding,lineRangeForRange,linguisticTagsInRange,localizedCaseInsensitiveCompare,localizedCompare,localizedStandardCompare,lowercaseStringWithLocale,maximumLengthOfBytesUsingEncoding,paragraphRangeForRange,propertyList,propertyListFromStringsFileFormat,rangeOfCharacterFromSet,rangeOfComposedCharacterSequenceAtIndex,rangeOfComposedCharacterSequencesForRange,rangeOfString,localizedStandardContainsString,localizedStandardRangeOfString,stringByAddingPercentEncodingWithAllowedCharacters,stringByAddingPercentEscapesUsingEncoding,stringByAppendingFormat,stringByAppendingString,stringByFoldingWithOptions,stringByPaddingToLength,stringByReplacingCharactersInRange,stringByReplacingOccurrencesOfString,stringByReplacingPercentEscapesUsingEncoding,stringByTrimmingCharactersInSet,substringFromIndex,substringToIndex,substringWithRange,uppercaseStringWithLocale,writeToFile,writeToURL,stringByApplyingTransform,containsString,localizedCaseInsensitiveContainsString,startIndex,endIndex,characters,utf16,utf8,nulTerminatedUTF8,debugDescription,hashValue,lowercaseString,uppercaseString,isEmpty,unicodeScalars,capitalizedString,localizedCapitalizedString,decomposedStringWithCanonicalMapping,decomposedStringWithCompatibilityMapping,fastestEncoding,hash,localizedLowercaseString,precomposedStringWithCanonicalMapping,precomposedStringWithCompatibilityMapping,smallestEncoding,stringByRemovingPercentEncoding,localizedUppercaseString,Index,UnicodeScalarIndex,UTF16Index,UTF8Index">
    <link rel="canonical" href="http://swiftdoc.org/v2.0/type/String/">
    <link rel="Shortcut Icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="apple-touch-icon" href="/images/touch-icon-iphone.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/assets/images/touch-icon-ipad.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/assets/images/touch-icon-iphone-retina.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/assets/images/touch-icon-ipad-retina.png">
    <link rel="alternate" type="application/rss+xml" title="SwiftDoc.org" href="/feed.xml" />

    <meta property="og:site_name" content="SwiftDoc.org"/>
    <meta property="og:image" content="http://swiftdoc.org/assets/images/touch-icon-ipad-retina.png"/>
    <meta property="og:title" content="String"/>
    <meta property="og:url" content="http://swiftdoc.org/v2.0/type/String/index.html"/>
    <meta property="og:description" content="Swift documentation for 'String': An arbitrary Unicode string value."/>

    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:site" content="@SwiftDocOrg"/>
    <meta name="twitter:creator" content="@SwiftDocOrg"/>
    <meta name="twitter:title" content="String"/>
    <meta name="twitter:image" content="http://swiftdoc.org/assets/images/touch-icon-ipad-retina.png"/>
    <meta name="twitter:description" content="Swift documentation for 'String': An arbitrary Unicode string value."/>
    <meta name="twitter:url" content="http://swiftdoc.org/v2.0/type/String/index.html"/>

    <link href="/assets/swift-ad53d83d7f511c875fe435187584402e.css" rel="stylesheet" type="text/css" />
    <script src="/assets/swift-1180b690b3443cebd37afe75496dce73.js" type="text/javascript"></script>

    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    
    <script src="/v2.0/assets/js/swift-linkdata.js"></script>
    
  </head>

  <body class="p-v2.0 p-type p-String">
    <div id="wrapper">

        
	<nav class="navbar navbar-default" role="navigation" id="navbar">
      <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <h1><a href="/">SwiftDoc.org</a></h1>
          <span class="version"></span>
        </div>
	    <div class="collapse navbar-collapse navbar-ex1-collapse">
          <form class="navbar-form navbar-left" role="search">
          
    		<div class="form-group input-group has-feedback">
    			<input type="hidden" class="form-control select2">
    			<span class="glyphicon glyphicon-search form-control-feedback"></span>
    		</div>
            
          </form>
          <ul class="nav navbar-nav navbar-right">
              <li><a href="/type/">Types</a></li>
              <li><a href="/protocol/">Protocols</a></li>
              <li><a href="/operator/">Operators</a></li>
              <li><a href="/global/">Globals</a></li>
          </ul>
	    </div>
	</nav>				

	<div id="header">
		<div class="container">
			<h1><a href="/">SwiftDoc.org</a></h1>
			<p>Auto-generated documentation for <a href="https://developer.apple.com/swift/">Swift</a>. Command-click no more.</p>
			
			
		</div>
	</div>

    
    <div id="version">
		<div class="container">
    		
			Swift version: <a href="/v1.2/">1.2</a> &nbsp;|&nbsp; <strong>2.0</strong>
    		
		</div>
    </div>
    
    
	
    <div class="container">
      <div class="row">
        <div class="col-sm-4 col-md-3" id="sidebar">

    		<div class="form-group input-group has-feedback">
    			<input type="hidden" class="form-control select2">
    			<span class="glyphicon glyphicon-search form-control-feedback"></span>
    		</div>

            <div class="panel-group" id="accordion">

  <div class="panel">
    <div class="panel-heading">
      <h4 class="panel-title">
        <a data-toggle="collapse" data-parent="#accordion" href="#collapseTypes">
          Types
        </a>
      </h4>
    </div>
    <div id="collapseTypes" class="panel-collapse collapse">
      <div class="panel-body list-group">
      </div>
    </div>
  </div>

  <div class="panel">
    <div class="panel-heading">
      <h4 class="panel-title">
        <a data-toggle="collapse" data-parent="#accordion" href="#collapseProtocols">
          Protocols
        </a>
      </h4>
    </div>
    <div id="collapseProtocols" class="panel-collapse collapse">
      <div class="panel-body list-group">
      </div>
    </div>
  </div>

  <div class="panel">
    <div class="panel-heading">
      <h4 class="panel-title">
        <a data-toggle="collapse" data-parent="#accordion" href="#collapseOperators">
          Operators
        </a>
      </h4>
    </div>
    <div id="collapseOperators" class="panel-collapse collapse">
      <div class="panel-body list-group">
      </div>
    </div>
  </div>

  <div class="panel">
    <div class="panel-heading">
      <h4 class="panel-title">
        <a data-toggle="collapse" data-parent="#accordion" href="#collapseGlobals">
          Globals
        </a>
      </h4>
    </div>
    <div id="collapseGlobals" class="panel-collapse collapse">
      <div class="panel-body list-group">
      </div>
    </div>
  </div>

</div>

        </div>

        <div class="col-sm-8 col-md-9" id="content">
          <header>
            <h2>String</h2>
          </header>
          
          <article class="content">
          <code class="language-swift">struct String { ... }</code>

<div class="comment">
    <p>An arbitrary Unicode string value.</p>

<h1>Unicode-Correct</h1>

<p>Swift strings are designed to be Unicode-correct.  In particular,
the APIs make it easy to write code that works correctly, and does
not surprise end-users, regardless of where you venture in the
Unicode character space.  For example, the <code>==</code> operator checks
for <a href="http://www.unicode.org/glossary/#deterministic_comparison">Unicode canonical
equivalence</a>,
so two different representations of the same string will always
compare equal.</p>

<h1>Locale-Insensitive</h1>

<p>The fundamental operations on Swift strings are not sensitive to
locale settings.  That&#39;s because, for example, the validity of a
<code>Dictionary&lt;String, T&gt;</code> in a running program depends on a given
string comparison having a single, stable result.  Therefore,
Swift always uses the default,
un-<a href="http://www.unicode.org/glossary/#tailorable">tailored</a> Unicode
algorithms for basic string operations.</p>

<p>Importing <code>Foundation</code> endows swift strings with the full power of
the <code>NSString</code> API, which allows you to choose more complex
locale-sensitive operations explicitly.</p>

<h1>Value Semantics</h1>

<p>Each string variable, <code>let</code> binding, or stored property has an
independent value, so mutations to the string are not observable
through its copies:</p>

<pre><code class="language-swift">var a = &quot;foo&quot;
var b = a
b.appendContentsOf(&quot;bar&quot;)
print(&quot;a=\(a), b=\(b)&quot;)     // a=foo, b=foobar</code></pre>

<p>Strings use Copy-on-Write so that their data is only copied
lazily, upon mutation, when more than one string instance is using
the same buffer.  Therefore, the first in any sequence of mutating
operations may cost <code>O(N)</code> time and space, where <code>N</code> is the length
of the string&#39;s (unspecified) underlying representation.</p>

<h1>Views</h1>

<p><code>String</code> is not itself a collection of anything.  Instead, it has
properties that present the string&#39;s contents as meaningful
collections:</p>

<p>  <strong><code>characters</code>:</strong> a collection of <code>Character</code> (<a href="http://www.unicode.org/glossary/#extended_grapheme_cluster">extended grapheme
    cluster</a>)
    elements, a unit of text that is meaningful to most humans.</p>

<p>  <strong><code>unicodeScalars</code>:</strong> a collection of <code>UnicodeScalar</code> (<a href="http://www.unicode.org/glossary/#unicode_scalar_value">Unicode
    scalar
    values</a>)
    the 21-bit codes that are the basic unit of Unicode.  These
    values are equivalent to UTF-32 code units.</p>

<p>  <strong><code>utf16</code>:</strong> a collection of <code>UTF16.CodeUnit</code>, the 16-bit
    elements of the string&#39;s UTF-16 encoding.</p>

<p>  <strong><code>utf8</code>:</strong> a collection of <code>UTF8.CodeUnit</code>, the 8-bit
    elements of the string&#39;s UTF-8 encoding.</p>

<h1>Growth and Capacity</h1>

<p>When a string&#39;s contiguous storage fills up, new storage must be
allocated and characters must be moved to the new storage.
<code>String</code> uses an exponential growth strategy that makes <code>append</code> a
constant time operation <em>when amortized over many invocations</em>.</p>

<h1>Objective-C Bridge</h1>

<p><code>String</code> is bridged to Objective-C as <code>NSString</code>, and a <code>String</code>
that originated in Objective-C may store its characters in an
<code>NSString</code>.  Since any arbitrary subclass of <code>NSSString</code> can
become a <code>String</code>, there are no guarantees about representation or
efficiency in this case.  Since <code>NSString</code> is immutable, it is
just as though the storage was shared by some copy: the first in
any sequence of mutating operations causes elements to be copied
into unique, contiguous storage which may cost <code>O(N)</code> time and
space, where <code>N</code> is the length of the string representation (or
more, if the underlying <code>NSString</code> is has unusual performance
characteristics).</p>
</div>

<h3>Inheritance</h3>
<code class="inherits">_Reflectable, OutputStreamType, Streamable, UnicodeScalarLiteralConvertible, ExtendedGraphemeClusterLiteralConvertible, StringLiteralConvertible, CustomDebugStringConvertible, Equatable, Comparable, Hashable, StringInterpolationConvertible, MirrorPathType, _ObjectiveCBridgeable</code>
<span class="viz"><a href="hierarchy/">Protocol hierarchy</a></span>

<h3 id="aliases">Associated types</h3>
<div class="declaration">
<code class="language-swift">typealias Index = String.CharacterView.Index</code>
</div>
<div class="declaration">
<code class="language-swift">typealias UnicodeScalarIndex = String.UnicodeScalarView.Index</code>
<div class="comment">
    <p>The index type for subscripting a <code>String</code>&#39;s <code>.unicodeScalars</code>
view.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias UTF16Index = String.UTF16View.Index</code>
<div class="comment">
    <p>The index type for subscripting a <code>String</code>&#39;s <code>utf16</code> view.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">typealias UTF8Index = String.UTF8View.Index</code>
<div class="comment">
    <p>The index type for subscripting a <code>String</code>&#39;s <code>.utf8</code> view.</p>
</div>
</div>

<h3>Nested types</h3>
<code class="nested">String.CharacterView, String.UnicodeScalarView, String.UTF16View, String.UTF8View, String.CharacterView.Index, String.UnicodeScalarView.Index, String.UnicodeScalarView.Generator, String.UTF16View.Index, String.UTF8View.Index</code>


<h3>Initializers</h3>
<div class="declaration">
<code class="language-swift">init()</code>
<div class="comment">
    <p>An empty <code>String</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(_ characters: String.CharacterView)</code>
<div class="comment">
    <p>Construct the <code>String</code> corresponding to the given sequence of
Unicode scalars.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(_ unicodeScalars: String.UnicodeScalarView)</code>
<div class="comment">
    <p>Construct the <code>String</code> corresponding to the given sequence of
Unicode scalars.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init?(_ utf16: String.UTF16View)</code>
<div class="comment">
    <p>Construct the <code>String</code> corresponding to the given sequence of
UTF-16 code units.  If <code>utf16</code> contains unpaired surrogates, the
result is <code>nil</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init?(_ utf8: String.UTF8View)</code>
<div class="comment">
    <p>Construct the <code>String</code> corresponding to the given sequence of
UTF-8 code units.  If <code>utf8</code> contains unpaired surrogates, the
result is <code>nil</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(_ c: Character)</code>
<div class="comment">
    <p>Construct an instance containing just the given <code>Character</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(_builtinUnicodeScalarLiteral value: Builtin.Int32)</code>
</div>
<div class="declaration">
<code class="language-swift">init(unicodeScalarLiteral value: String)</code>
<div class="comment">
    <p>Create an instance initialized to <code>value</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(_builtinExtendedGraphemeClusterLiteral start: Builtin.RawPointer, byteSize: Builtin.Word, isASCII: Builtin.Int1)</code>
</div>
<div class="declaration">
<code class="language-swift">init(extendedGraphemeClusterLiteral value: String)</code>
<div class="comment">
    <p>Create an instance initialized to <code>value</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(_builtinUTF16StringLiteral start: Builtin.RawPointer, numberOfCodeUnits: Builtin.Word)</code>
</div>
<div class="declaration">
<code class="language-swift">init(_builtinStringLiteral start: Builtin.RawPointer, byteSize: Builtin.Word, isASCII: Builtin.Int1)</code>
</div>
<div class="declaration">
<code class="language-swift">init(stringLiteral value: String)</code>
<div class="comment">
    <p>Create an instance initialized to <code>value</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init&lt;S : SequenceType where S.Generator.Element == Character&gt;(_ characters: S)</code>
<div class="comment">
    <p>Create an instance containing <code>characters</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(stringInterpolation strings: String...)</code>
<div class="comment">
    <p>Create an instance by concatenating the elements of <code>strings</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init&lt;T&gt;(stringInterpolationSegment expr: T)</code>
<div class="comment">
    <p>Create an instance containing <code>expr</code>&#39;s <code>print</code> representation.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(stringInterpolationSegment expr: String)</code>
</div>
<div class="declaration">
<code class="language-swift">init(stringInterpolationSegment expr: Character)</code>
</div>
<div class="declaration">
<code class="language-swift">init(stringInterpolationSegment expr: UnicodeScalar)</code>
</div>
<div class="declaration">
<code class="language-swift">init(stringInterpolationSegment expr: Bool)</code>
</div>
<div class="declaration">
<code class="language-swift">init(stringInterpolationSegment expr: Float32)</code>
</div>
<div class="declaration">
<code class="language-swift">init(stringInterpolationSegment expr: Float64)</code>
</div>
<div class="declaration">
<code class="language-swift">init(stringInterpolationSegment expr: UInt8)</code>
</div>
<div class="declaration">
<code class="language-swift">init(stringInterpolationSegment expr: Int8)</code>
</div>
<div class="declaration">
<code class="language-swift">init(stringInterpolationSegment expr: UInt16)</code>
</div>
<div class="declaration">
<code class="language-swift">init(stringInterpolationSegment expr: Int16)</code>
</div>
<div class="declaration">
<code class="language-swift">init(stringInterpolationSegment expr: UInt32)</code>
</div>
<div class="declaration">
<code class="language-swift">init(stringInterpolationSegment expr: Int32)</code>
</div>
<div class="declaration">
<code class="language-swift">init(stringInterpolationSegment expr: UInt64)</code>
</div>
<div class="declaration">
<code class="language-swift">init(stringInterpolationSegment expr: Int64)</code>
</div>
<div class="declaration">
<code class="language-swift">init(stringInterpolationSegment expr: UInt)</code>
</div>
<div class="declaration">
<code class="language-swift">init(stringInterpolationSegment expr: Int)</code>
</div>
<div class="declaration">
<code class="language-swift">init(count: Int, repeatedValue c: Character)</code>
<div class="comment">
    <p>Construct an instance that is the concatenation of <code>count</code> copies
of <code>repeatedValue</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(count: Int, repeatedValue c: UnicodeScalar)</code>
<div class="comment">
    <p>Construct an instance that is the concatenation of <code>count</code> copies
of <code>Character(repeatedValue)</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init&lt;T : _SignedIntegerType&gt;(_ v: T)</code>
<div class="comment">
    <p>Create an instance representing <code>v</code> in base 10.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init&lt;T : UnsignedIntegerType&gt;(_ v: T)</code>
<div class="comment">
    <p>Create an instance representing <code>v</code> in base 10.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init&lt;T : _SignedIntegerType&gt;(_ v: T, radix: Int, uppercase: Bool = default)</code>
<div class="comment">
    <p>Create an instance representing <code>v</code> in the given <code>radix</code> (base).</p>

<p>Numerals greater than 9 are represented as roman letters,
starting with <code>a</code> if <code>uppercase</code> is <code>false</code> or <code>A</code> otherwise.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init&lt;T : UnsignedIntegerType&gt;(_ v: T, radix: Int, uppercase: Bool = default)</code>
<div class="comment">
    <p>Create an instance representing <code>v</code> in the given <code>radix</code> (base).</p>

<p>Numerals greater than 9 are represented as roman letters,
starting with <code>a</code> if <code>uppercase</code> is <code>false</code> or <code>A</code> otherwise.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init&lt;T&gt;(_ instance: T)</code>
<div class="comment">
    <p>Initialize <code>self</code> with the textual representation of <code>instance</code>.</p>

<ul><li>If <code>T</code> conforms to <code>Streamable</code>, the result is obtained by
calling <code>instance.writeTo(s)</code> on an empty string s.</li><li>Otherwise, if <code>T</code> conforms to <code>CustomStringConvertible</code>, the
result is <code>instance</code>&#39;s <code>description</code></li><li>Otherwise, if <code>T</code> conforms to <code>CustomDebugStringConvertible</code>,
the result is <code>instance</code>&#39;s <code>debugDescription</code></li><li>Otherwise, an unspecified result is supplied automatically by
the Swift standard library.</li></ul>

<p><strong>See Also:</strong> <code>String.init&lt;T&gt;(reflecting: T)</code></p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init&lt;T&gt;(reflecting subject: T)</code>
<div class="comment">
    <p>Initialize <code>self</code> with a detailed textual representation of
<code>subject</code>, suitable for debugging.</p>

<ul><li><p>If <code>T</code> conforms to <code>CustomDebugStringConvertible</code>, the result
is <code>subject</code>&#39;s <code>debugDescription</code>.</p></li><li><p>Otherwise, if <code>T</code> conforms to <code>CustomStringConvertible</code>, the result
is <code>subject</code>&#39;s <code>description</code>.</p></li><li><p>Otherwise, if <code>T</code> conforms to <code>Streamable</code>, the result is
obtained by calling <code>subject.writeTo(s)</code> on an empty string s.</p></li><li><p>Otherwise, an unspecified result is supplied automatically by
the Swift standard library.</p></li></ul>

<p><strong>See Also:</strong> <code>String.init&lt;T&gt;(T)</code></p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init?(UTF8String bytes: UnsafePointer&lt;CChar&gt;)</code>
<div class="comment">
    <p><em>[Foundation]</em> Produces a string created by copying the data from a given
C array of UTF8-encoded bytes.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init?&lt;S : SequenceType where S.Generator.Element == UInt8&gt;(bytes: S, encoding: NSStringEncoding)</code>
<div class="comment">
    <p><em>[Foundation]</em> Produces an initialized <code>NSString</code> object equivalent to the given
<code>bytes</code> interpreted in the given <code>encoding</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init?(bytesNoCopy bytes: UnsafeMutablePointer&lt;Void&gt;, length: Int, encoding: NSStringEncoding, freeWhenDone flag: Bool)</code>
<div class="comment">
    <p><em>[Foundation]</em> Produces an initialized <code>String</code> object that contains a
given number of bytes from a given buffer of bytes interpreted
in a given encoding, and optionally frees the buffer.  WARNING:
this initializer is not memory-safe!</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(utf16CodeUnits: UnsafePointer&lt;unichar&gt;, count: Int)</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns an initialized <code>String</code> object that contains a
given number of characters from a given array of Unicode
characters.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(utf16CodeUnitsNoCopy: UnsafePointer&lt;unichar&gt;, count: Int, freeWhenDone flag: Bool)</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns an initialized <code>String</code> object that contains a given
number of characters from a given array of UTF-16 Code Units</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(contentsOfFile path: String, encoding enc: NSStringEncoding)</code>
<div class="comment">
    <p><em>[Foundation]</em> Produces a string created by reading data from the file at a
given path interpreted using a given encoding.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(contentsOfFile path: String, usedEncoding: UnsafeMutablePointer&lt;NSStringEncoding&gt; = default)</code>
<div class="comment">
    <p><em>[Foundation]</em> Produces a string created by reading data from the file at
a given path and returns by reference the encoding used to
interpret the file.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(contentsOfURL url: NSURL, encoding enc: NSStringEncoding)</code>
<div class="comment">
    <p><em>[Foundation]</em> Produces a string created by reading data from a given URL
interpreted using a given encoding.  Errors are written into the
inout <code>error</code> argument.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(contentsOfURL url: NSURL, usedEncoding enc: UnsafeMutablePointer&lt;NSStringEncoding&gt; = default)</code>
<div class="comment">
    <p><em>[Foundation]</em> Produces a string created by reading data from a given URL
and returns by reference the encoding used to interpret the
data.  Errors are written into the inout <code>error</code> argument.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init?(CString: UnsafePointer&lt;CChar&gt;, encoding enc: NSStringEncoding)</code>
<div class="comment">
    <p><em>[Foundation]</em> Produces a string containing the bytes in a given C array,
interpreted according to a given encoding.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init?(data: NSData, encoding: NSStringEncoding)</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a <code>String</code> initialized by converting given <code>data</code> into
Unicode characters using a given <code>encoding</code>.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(format: String, _ arguments: CVarArgType...)</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a <code>String</code> object initialized by using a given
format string as a template into which the remaining argument
values are substituted.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(format: String, arguments: [CVarArgType])</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a <code>String</code> object initialized by using a given
format string as a template into which the remaining argument
values are substituted according to the user’s default locale.
 </p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(format: String, locale: NSLocale?, _ args: CVarArgType...)</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a <code>String</code> object initialized by using a given
format string as a template into which the remaining argument
values are substituted according to given locale information.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(format: String, locale: NSLocale?, arguments: [CVarArgType])</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a <code>String</code> object initialized by using a given
format string as a template into which the remaining argument
values are substituted according to given locale information.</p>
</div>
</div>
<div class="declaration">
<code class="language-swift">init(_ cocoaString: NSString)</code>
<div class="comment">
    <p><em>[Foundation]</em></p>
</div>
</div>


<h3>Instance Variables</h3>
<div class="declaration" id="prop-startIndex">
<code class="language-swift">var startIndex: Index { get }</code>
<div class="comment">
    <p>The position of the first <code>Character</code> in <code>self.characters</code> if
<code>self</code> is non-empty; identical to <code>endIndex</code> otherwise.</p>
</div>
</div>
<div class="declaration" id="prop-endIndex">
<code class="language-swift">var endIndex: Index { get }</code>
<div class="comment">
    <p>The &quot;past the end&quot; position in <code>self.characters</code>.</p>

<p><code>endIndex</code> is not a valid argument to <code>subscript</code>, and is always
reachable from <code>startIndex</code> by zero or more applications of
<code>successor()</code>.</p>
</div>
</div>
<div class="declaration" id="prop-characters">
<code class="language-swift">var characters: String.CharacterView { get }</code>
<div class="comment">
    <p>A collection of <code>Characters</code> representing the <code>String</code>&#39;s
<a href="http://www.unicode.org/glossary/#extended_grapheme_cluster">extended grapheme
clusters</a>.</p>
</div>
</div>
<div class="declaration" id="prop-utf16">
<code class="language-swift">var utf16: String.UTF16View { get }</code>
<div class="comment">
    <p>A UTF-16 encoding of <code>self</code>.</p>
</div>
</div>
<div class="declaration" id="prop-utf8">
<code class="language-swift">var utf8: String.UTF8View { get }</code>
<div class="comment">
    <p>A UTF-8 encoding of <code>self</code>.</p>
</div>
</div>
<div class="declaration" id="prop-nulTerminatedUTF8">
<code class="language-swift">var nulTerminatedUTF8: ContiguousArray&lt;CodeUnit&gt; { get }</code>
<div class="comment">
    <p>A contiguously-stored nul-terminated UTF-8 representation of
<code>self</code>.</p>

<p>To access the underlying memory, invoke
<code>withUnsafeBufferPointer</code> on the <code>ContiguousArray</code>.</p>
</div>
</div>
<div class="declaration" id="prop-debugDescription">
<code class="language-swift">var debugDescription: String { get }</code>
<div class="comment">
    <p>A textual representation of <code>self</code>, suitable for debugging.</p>
</div>
</div>
<div class="declaration" id="prop-hashValue">
<code class="language-swift">var hashValue: Int { get }</code>
<div class="comment">
    <p>The hash value.</p>

<p><strong>Axiom:</strong> <code>x == y</code> implies <code>x.hashValue == y.hashValue</code>.</p>

<p><strong>Note:</strong> The hash value is not guaranteed to be stable across
  different invocations of the same program.  Do not persist the
  hash value across program runs.</p>
</div>
</div>
<div class="declaration" id="prop-lowercaseString">
<code class="language-swift">var lowercaseString: String { get }</code>
</div>
<div class="declaration" id="prop-uppercaseString">
<code class="language-swift">var uppercaseString: String { get }</code>
</div>
<div class="declaration" id="prop-isEmpty">
<code class="language-swift">var isEmpty: Bool { get }</code>
<div class="comment">
    <p><code>true</code> iff <code>self</code> contains no characters.</p>
</div>
</div>
<div class="declaration" id="prop-unicodeScalars">
<code class="language-swift">var unicodeScalars: String.UnicodeScalarView { get set }</code>
<div class="comment">
    <p>The value of <code>self</code> as a collection of <a href="http://www.unicode.org/glossary/#unicode_scalar_value">Unicode scalar values</a>.</p>
</div>
</div>
<div class="declaration" id="prop-capitalizedString">
<code class="language-swift">var capitalizedString: String { get }</code>
<div class="comment">
    <p><em>[Foundation]</em> Produce a string with the first character from each word changed
to the corresponding uppercase value.</p>
</div>
</div>
<div class="declaration" id="prop-localizedCapitalizedString">
<code class="language-swift">var localizedCapitalizedString: String { get }</code>
<div class="comment">
    <p><em>[Foundation]</em> A capitalized representation of the <code>String</code> that is produced
using the current locale.</p>
</div>
</div>
<div class="declaration" id="prop-decomposedStringWithCanonicalMapping">
<code class="language-swift">var decomposedStringWithCanonicalMapping: String { get }</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a string made by normalizing the <code>String</code>’s</p>

<p>contents using Form D.</p>
</div>
</div>
<div class="declaration" id="prop-decomposedStringWithCompatibilityMapping">
<code class="language-swift">var decomposedStringWithCompatibilityMapping: String { get }</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a string made by normalizing the <code>String</code>’s</p>

<p>contents using Form KD.</p>
</div>
</div>
<div class="declaration" id="prop-fastestEncoding">
<code class="language-swift">var fastestEncoding: NSStringEncoding { get }</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns the fastest encoding to which the <code>String</code> may be
converted without loss of information.</p>
</div>
</div>
<div class="declaration" id="prop-hash">
<code class="language-swift">var hash: Int { get }</code>
<div class="comment">
    <p><em>[Foundation]</em> An unsigned integer that can be used as a hash table address.</p>
</div>
</div>
<div class="declaration" id="prop-localizedLowercaseString">
<code class="language-swift">var localizedLowercaseString: String { get }</code>
<div class="comment">
    <p><em>[Foundation]</em> A lowercase version of the string that is produced using the current
locale.</p>
</div>
</div>
<div class="declaration" id="prop-precomposedStringWithCanonicalMapping">
<code class="language-swift">var precomposedStringWithCanonicalMapping: String { get }</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a string made by normalizing the <code>String</code>’s</p>

<p>contents using Form C.</p>
</div>
</div>
<div class="declaration" id="prop-precomposedStringWithCompatibilityMapping">
<code class="language-swift">var precomposedStringWithCompatibilityMapping: String { get }</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a string made by normalizing the <code>String</code>’s</p>

<p>contents using Form KC.</p>
</div>
</div>
<div class="declaration" id="prop-smallestEncoding">
<code class="language-swift">var smallestEncoding: NSStringEncoding { get }</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns the smallest encoding to which the <code>String</code> can
be converted without loss of information.</p>
</div>
</div>
<div class="declaration" id="prop-stringByRemovingPercentEncoding">
<code class="language-swift">var stringByRemovingPercentEncoding: String? { get }</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a new string made from the <code>String</code> by replacing
all percent encoded sequences with the matching UTF-8
characters.</p>
</div>
</div>
<div class="declaration" id="prop-localizedUppercaseString">
<code class="language-swift">var localizedUppercaseString: String { get }</code>
<div class="comment">
    <p><em>[Foundation]</em> An uppercase version of the string that is produced using the current
locale.</p>
</div>
</div>

<h3>Static Methods</h3>
<div class="declaration" id="func-fromCString">
<code class="language-swift">static func fromCString(cs: UnsafePointer&lt;CChar&gt;) -> String?</code>
<div class="comment">
    <p>Creates a new <code>String</code> by copying the nul-terminated UTF-8 data
referenced by a <code>CString</code>.</p>

<p>Returns <code>nil</code> if the <code>CString</code> is <code>NULL</code> or if it contains ill-formed
UTF-8 code unit sequences.</p>
</div>
</div>
<div class="declaration" id="func-fromCStringRepairingIllFormedUTF8">
<code class="language-swift">static func fromCStringRepairingIllFormedUTF8(cs: UnsafePointer&lt;CChar&gt;) -> (String?, hadError: Bool)</code>
<div class="comment">
    <p>Creates a new <code>String</code> by copying the nul-terminated UTF-8 data
referenced by a <code>CString</code>.</p>

<p>Returns <code>nil</code> if the <code>CString</code> is <code>NULL</code>.  If <code>CString</code> contains
ill-formed UTF-8 code unit sequences, replaces them with replacement
characters (U+FFFD).</p>
</div>
</div>
<div class="declaration" id="func-availableStringEncodings">
<code class="language-swift">static func availableStringEncodings() -> [NSStringEncoding]</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns an Array of the encodings string objects support
in the application’s environment.
 </p>
</div>
</div>
<div class="declaration" id="func-defaultCStringEncoding">
<code class="language-swift">static func defaultCStringEncoding() -> NSStringEncoding</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns the C-string encoding assumed for any method accepting
a C string as an argument.</p>
</div>
</div>
<div class="declaration" id="func-localizedNameOfStringEncoding">
<code class="language-swift">static func localizedNameOfStringEncoding(encoding: NSStringEncoding) -> String</code>
<div class="comment">
    <p>Returns a human-readable string giving the name of a given encoding.</p>
</div>
</div>
<div class="declaration" id="func-localizedStringWithFormat">
<code class="language-swift">static func localizedStringWithFormat(format: String, _ arguments: CVarArgType...) -> String</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a string created by using a given format string as a
template into which the remaining argument values are substituted
according to the user&#39;s default locale.</p>
</div>
</div>

<h3>Instance Methods</h3>
<div class="declaration" id="func-withMutableCharacters">
<code class="language-swift">mutating func withMutableCharacters&lt;R&gt;(body: (inout String.CharacterView) -&gt; R) -> R</code>
<div class="comment">
    <p>Efficiently mutate <code>self</code> by applying <code>body</code> to its <code>characters</code>.</p>

<p><strong>Warning:</strong> Do not rely on anything about <code>self</code> (the <code>String</code>
  that is the target of this method) during the execution of
  <code>body</code>: it may not appear to have its correct value.  Instead,
  use only the <code>String.CharacterView</code> argument to <code>body</code>.</p>
</div>
</div>
<div class="declaration" id="func-withCString">
<code class="language-swift">func withCString&lt;Result&gt;(@noescape f: UnsafePointer&lt;Int8&gt; throws -&gt; Result) rethrows -> Result</code>
<div class="comment">
    <p>Invoke <code>f</code> on the contents of this string, represented as
a nul-terminated array of char, ensuring that the array&#39;s
lifetime extends through the execution of <code>f</code>.</p>
</div>
</div>
<div class="declaration" id="func-write">
<code class="language-swift">mutating func write(other: String) </code>
<div class="comment">
    <p>Append <code>other</code> to this stream.</p>
</div>
</div>
<div class="declaration" id="func-writeTo">
<code class="language-swift">func writeTo&lt;Target : OutputStreamType&gt;(inout target: Target) </code>
<div class="comment">
    <p>Write a textual representation of <code>self</code> into <code>target</code>.</p>
</div>
</div>
<div class="declaration" id="func-appendContentsOf">
<code class="language-swift">mutating func appendContentsOf(other: String) </code>
<div class="comment">
    <p>Append the elements of <code>other</code> to <code>self</code>.</p>
</div>
</div>
<div class="declaration" id="func-append">
<code class="language-swift">mutating func append(x: UnicodeScalar) </code>
<div class="comment">
    <p>Append <code>x</code> to <code>self</code>.</p>

<p><strong>Complexity:</strong> Amortized O(1).</p>
</div>
</div>
<div class="declaration" id="func-reserveCapacity">
<code class="language-swift">mutating func reserveCapacity(n: Int) </code>
</div>
<div class="declaration" id="func-append">
<code class="language-swift">mutating func append(c: Character) </code>
</div>
<div class="declaration" id="func-appendContentsOf">
<code class="language-swift">mutating func appendContentsOf&lt;S : SequenceType where S.Generator.Element == Character&gt;(newElements: S) </code>
</div>
<div class="declaration" id="func-replaceRange">
<code class="language-swift">mutating func replaceRange&lt;C : CollectionType where C.Generator.Element == Character&gt;(subRange: Range&lt;Index&gt;, with newElements: C) </code>
<div class="comment">
    <p>Replace the given <code>subRange</code> of elements with <code>newElements</code>.</p>

<p>Invalidates all indices with respect to <code>self</code>.</p>

<p><strong>Complexity:</strong> O(<code>subRange.count</code>) if <code>subRange.endIndex
  == self.endIndex</code> and <code>newElements.isEmpty</code>, O(N) otherwise.</p>
</div>
</div>
<div class="declaration" id="func-replaceRange">
<code class="language-swift">mutating func replaceRange(subRange: Range&lt;Index&gt;, with newElements: String) </code>
<div class="comment">
    <p>Replace the given <code>subRange</code> of elements with <code>newElements</code>.</p>

<p>Invalidates all indices with respect to <code>self</code>.</p>

<p><strong>Complexity:</strong> O(<code>subRange.count</code>) if <code>subRange.endIndex
  == self.endIndex</code> and <code>newElements.isEmpty</code>, O(N) otherwise.</p>
</div>
</div>
<div class="declaration" id="func-insert">
<code class="language-swift">mutating func insert(newElement: Character, atIndex i: Index) </code>
<div class="comment">
    <p>Insert <code>newElement</code> at index <code>i</code>.</p>

<p>Invalidates all indices with respect to <code>self</code>.</p>

<p><strong>Complexity:</strong> O(<code>self.count</code>).</p>
</div>
</div>
<div class="declaration" id="func-insertContentsOf">
<code class="language-swift">mutating func insertContentsOf&lt;S : CollectionType where S.Generator.Element == Character&gt;(newElements: S, at i: Index) </code>
<div class="comment">
    <p>Insert <code>newElements</code> at index <code>i</code>.</p>

<p>Invalidates all indices with respect to <code>self</code>.</p>

<p><strong>Complexity:</strong> O(<code>self.count + newElements.count</code>).</p>
</div>
</div>
<div class="declaration" id="func-removeAtIndex">
<code class="language-swift">mutating func removeAtIndex(i: Index) -> Character</code>
<div class="comment">
    <p>Remove and return the element at index <code>i</code>.</p>

<p>Invalidates all indices with respect to <code>self</code>.</p>

<p><strong>Complexity:</strong> O(<code>self.count</code>).</p>
</div>
</div>
<div class="declaration" id="func-removeRange">
<code class="language-swift">mutating func removeRange(subRange: Range&lt;Index&gt;) </code>
<div class="comment">
    <p>Remove the indicated <code>subRange</code> of characters.</p>

<p>Invalidates all indices with respect to <code>self</code>.</p>

<p><strong>Complexity:</strong> O(<code>self.count</code>).</p>
</div>
</div>
<div class="declaration" id="func-removeAll">
<code class="language-swift">mutating func removeAll(keepCapacity keepCapacity: Bool = default) </code>
<div class="comment">
    <p>Remove all characters.</p>

<p>Invalidates all indices with respect to <code>self</code>.</p>

<p><strong><code>keepCapacity</code>:</strong>  If <code>true</code>, prevents the release of
  allocated storage, which can be a useful optimization
  when <code>self</code> is going to be grown again.</p>
</div>
</div>
<div class="declaration" id="func-hasPrefix">
<code class="language-swift">func hasPrefix(prefix: String) -> Bool</code>
<div class="comment">
    <p>Returns <code>true</code> iff <code>self</code> begins with <code>prefix</code>.</p>
</div>
</div>
<div class="declaration" id="func-hasSuffix">
<code class="language-swift">func hasSuffix(suffix: String) -> Bool</code>
<div class="comment">
    <p>Returns <code>true</code> iff <code>self</code> ends with <code>suffix</code>.</p>
</div>
</div>
<div class="declaration" id="func-canBeConvertedToEncoding">
<code class="language-swift">func canBeConvertedToEncoding(encoding: NSStringEncoding) -> Bool</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a Boolean value that indicates whether the
<code>String</code> can be converted to a given encoding without loss of
information.</p>
</div>
</div>
<div class="declaration" id="func-capitalizedStringWithLocale">
<code class="language-swift">func capitalizedStringWithLocale(locale: NSLocale?) -> String</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a capitalized representation of the <code>String</code>
using the specified locale.</p>
</div>
</div>
<div class="declaration" id="func-caseInsensitiveCompare">
<code class="language-swift">func caseInsensitiveCompare(aString: String) -> NSComparisonResult</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns the result of invoking <code>compare:options:</code> with
<code>NSCaseInsensitiveSearch</code> as the only option.</p>
</div>
</div>
<div class="declaration" id="func-commonPrefixWithString">
<code class="language-swift">func commonPrefixWithString(aString: String, options: NSStringCompareOptions) -> String</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a string containing characters the <code>String</code> and a
given string have in common, starting from the beginning of each
up to the first characters that aren’t equivalent.
 </p>
</div>
</div>
<div class="declaration" id="func-compare">
<code class="language-swift">func compare(aString: String, options mask: NSStringCompareOptions = default, range: Range&lt;Index&gt;? = default, locale: NSLocale? = default) -> NSComparisonResult</code>
<div class="comment">
    <p><em>[Foundation]</em> Compares the string using the specified options and
returns the lexical ordering for the range.</p>
</div>
</div>
<div class="declaration" id="func-completePathIntoString">
<code class="language-swift">func completePathIntoString(outputName: UnsafeMutablePointer&lt;String&gt; = default, caseSensitive: Bool, matchesIntoArray: UnsafeMutablePointer&lt;[String]&gt; = default, filterTypes: [String]? = default) -> Int</code>
<div class="comment">
    <p><em>[Foundation]</em> Interprets the <code>String</code> as a path in the file system and
attempts to perform filename completion, returning a numeric
value that indicates whether a match was possible, and by
reference the longest path that matches the <code>String</code>.
Returns the actual number of matching paths.</p>
</div>
</div>
<div class="declaration" id="func-componentsSeparatedByCharactersInSet">
<code class="language-swift">func componentsSeparatedByCharactersInSet(separator: NSCharacterSet) -> [String]</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns an array containing substrings from the <code>String</code>
that have been divided by characters in a given set.</p>
</div>
</div>
<div class="declaration" id="func-componentsSeparatedByString">
<code class="language-swift">func componentsSeparatedByString(separator: String) -> [String]</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns an array containing substrings from the <code>String</code>
that have been divided by a given separator.</p>
</div>
</div>
<div class="declaration" id="func-cStringUsingEncoding">
<code class="language-swift">func cStringUsingEncoding(encoding: NSStringEncoding) -> [CChar]?</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a representation of the <code>String</code> as a C string
using a given encoding.</p>
</div>
</div>
<div class="declaration" id="func-dataUsingEncoding">
<code class="language-swift">func dataUsingEncoding(encoding: NSStringEncoding, allowLossyConversion: Bool = default) -> NSData?</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns an <code>NSData</code> object containing a representation of
the <code>String</code> encoded using a given encoding.</p>
</div>
</div>
<div class="declaration" id="func-enumerateLines">
<code class="language-swift">func enumerateLines(body: (line: String, inout stop: Bool) -&gt; ()) </code>
<div class="comment">
    <p><em>[Foundation]</em> Enumerates all the lines in a string.</p>
</div>
</div>
<div class="declaration" id="func-enumerateLinguisticTagsInRange">
<code class="language-swift">func enumerateLinguisticTagsInRange(range: Range&lt;Index&gt;, scheme tagScheme: String, options opts: NSLinguisticTaggerOptions, orthography: NSOrthography?, _ body: (String, Range&lt;Index&gt;, Range&lt;Index&gt;, inout Bool) -&gt; ()) </code>
<div class="comment">
    <p><em>[Foundation]</em> Performs linguistic analysis on the specified string by
enumerating the specific range of the string, providing the
Block with the located tags.</p>
</div>
</div>
<div class="declaration" id="func-enumerateSubstringsInRange">
<code class="language-swift">func enumerateSubstringsInRange(range: Range&lt;Index&gt;, options opts: NSStringEnumerationOptions, _ body: (substring: String?, substringRange: Range<Index>, enclosingRange: Range&lt;Index&gt;, inout Bool) -&gt; ()) </code>
<div class="comment">
    <p><em>[Foundation]</em> Enumerates the substrings of the specified type in the
specified range of the string.</p>
</div>
</div>
<div class="declaration" id="func-getBytes">
<code class="language-swift">func getBytes(inout buffer: [UInt8], maxLength maxBufferCount: Int, usedLength usedBufferCount: UnsafeMutablePointer&lt;Int&gt;, encoding: NSStringEncoding, options: NSStringEncodingConversionOptions, range: Range&lt;Index&gt;, remainingRange leftover: UnsafeMutablePointer&lt;Range&lt;Index&gt;&gt;) -> Bool</code>
<div class="comment">
    <p><em>[Foundation]</em> Writes the given <code>range</code> of characters into <code>buffer</code> in a given
<code>encoding</code>, without any allocations.  Does not NULL-terminate.</p>

<p><strong><code>buffer</code>:</strong>  A buffer into which to store the bytes from
  the receiver. The returned bytes are not NUL-terminated.</p>

<p><strong><code>maxBufferCount</code>:</strong>  The maximum number of bytes to write
  to buffer.</p>

<p><strong><code>usedBufferCount</code>:</strong>  The number of bytes used from
  buffer. Pass <code>nil</code> if you do not need this value.</p>

<p><strong><code>encoding</code>:</strong>  The encoding to use for the returned bytes.</p>

<p><strong><code>options</code>:</strong>  A mask to specify options to use for
  converting the receiver’s contents to <code>encoding</code> (if conversion</p>

<p>  is necessary).</p>

<p><strong><code>range</code>:</strong>  The range of characters in the receiver to get.</p>

<p><strong><code>leftover</code>:</strong>  The remaining range. Pass <code>nil</code> If you do
  not need this value.</p>

<p><strong>Returns:</strong> <code>true</code> iff some characters were converted.</p>

<p><strong>Note:</strong> Conversion stops when the buffer fills or when the
  conversion isn&#39;t possible due to the chosen encoding.</p>

<p><strong>Note:</strong> will get a maximum of <code>min(buffer.count, maxLength)</code> bytes.</p>
</div>
</div>
<div class="declaration" id="func-getCString">
<code class="language-swift">func getCString(inout buffer: [CChar], maxLength: Int, encoding: NSStringEncoding) -> Bool</code>
<div class="comment">
    <p><em>[Foundation]</em> Converts the <code>String</code>’s content to a given encoding and</p>

<p>stores them in a buffer.
<strong>Note:</strong> will store a maximum of <code>min(buffer.count, maxLength)</code> bytes.</p>
</div>
</div>
<div class="declaration" id="func-getLineStart">
<code class="language-swift">func getLineStart(start: UnsafeMutablePointer&lt;Index&gt;, end: UnsafeMutablePointer&lt;Index&gt;, contentsEnd: UnsafeMutablePointer&lt;Index&gt;, forRange: Range&lt;Index&gt;) </code>
<div class="comment">
    <p><em>[Foundation]</em> Returns by reference the beginning of the first line and
the end of the last line touched by the given range.</p>
</div>
</div>
<div class="declaration" id="func-getParagraphStart">
<code class="language-swift">func getParagraphStart(start: UnsafeMutablePointer&lt;Index&gt;, end: UnsafeMutablePointer&lt;Index&gt;, contentsEnd: UnsafeMutablePointer&lt;Index&gt;, forRange: Range&lt;Index&gt;) </code>
<div class="comment">
    <p><em>[Foundation]</em> Returns by reference the beginning of the first paragraph
and the end of the last paragraph touched by the given range.</p>
</div>
</div>
<div class="declaration" id="func-lengthOfBytesUsingEncoding">
<code class="language-swift">func lengthOfBytesUsingEncoding(encoding: NSStringEncoding) -> Int</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns the number of bytes required to store the
<code>String</code> in a given encoding.</p>
</div>
</div>
<div class="declaration" id="func-lineRangeForRange">
<code class="language-swift">func lineRangeForRange(aRange: Range&lt;Index&gt;) -> Range&lt;Index&gt;</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns the range of characters representing the line or lines
containing a given range.</p>
</div>
</div>
<div class="declaration" id="func-linguisticTagsInRange">
<code class="language-swift">func linguisticTagsInRange(range: Range&lt;Index&gt;, scheme tagScheme: String, options opts: NSLinguisticTaggerOptions = default, orthography: NSOrthography? = default, tokenRanges: UnsafeMutablePointer&lt;[Range&lt;Index&gt;]&gt; = default) -> [String]</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns an array of linguistic tags for the specified
range and requested tags within the receiving string.</p>
</div>
</div>
<div class="declaration" id="func-localizedCaseInsensitiveCompare">
<code class="language-swift">func localizedCaseInsensitiveCompare(aString: String) -> NSComparisonResult</code>
<div class="comment">
    <p><em>[Foundation]</em> Compares the string and a given string using a
case-insensitive, localized, comparison.</p>
</div>
</div>
<div class="declaration" id="func-localizedCompare">
<code class="language-swift">func localizedCompare(aString: String) -> NSComparisonResult</code>
<div class="comment">
    <p><em>[Foundation]</em> Compares the string and a given string using a localized
comparison.</p>
</div>
</div>
<div class="declaration" id="func-localizedStandardCompare">
<code class="language-swift">func localizedStandardCompare(string: String) -> NSComparisonResult</code>
<div class="comment">
    <p><em>[Foundation]</em> Compares strings as sorted by the Finder.</p>
</div>
</div>
<div class="declaration" id="func-lowercaseStringWithLocale">
<code class="language-swift">func lowercaseStringWithLocale(locale: NSLocale?) -> String</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a version of the string with all letters
converted to lowercase, taking into account the specified
locale.</p>
</div>
</div>
<div class="declaration" id="func-maximumLengthOfBytesUsingEncoding">
<code class="language-swift">func maximumLengthOfBytesUsingEncoding(encoding: NSStringEncoding) -> Int</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns the maximum number of bytes needed to store the
<code>String</code> in a given encoding.</p>
</div>
</div>
<div class="declaration" id="func-paragraphRangeForRange">
<code class="language-swift">func paragraphRangeForRange(aRange: Range&lt;Index&gt;) -> Range&lt;Index&gt;</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns the range of characters representing the
paragraph or paragraphs containing a given range.</p>
</div>
</div>
<div class="declaration" id="func-propertyList">
<code class="language-swift">func propertyList() -> AnyObject</code>
<div class="comment">
    <p><em>[Foundation]</em> Parses the <code>String</code> as a text representation of a
property list, returning an NSString, NSData, NSArray, or
NSDictionary object, according to the topmost element.</p>
</div>
</div>
<div class="declaration" id="func-propertyListFromStringsFileFormat">
<code class="language-swift">func propertyListFromStringsFileFormat() -> [String : String]</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a dictionary object initialized with the keys and
values found in the <code>String</code>.</p>
</div>
</div>
<div class="declaration" id="func-rangeOfCharacterFromSet">
<code class="language-swift">func rangeOfCharacterFromSet(aSet: NSCharacterSet, options mask: NSStringCompareOptions = default, range aRange: Range&lt;Index&gt;? = default) -> Range&lt;Index&gt;?</code>
<div class="comment">
    <p><em>[Foundation]</em> Finds and returns the range in the <code>String</code> of the first
character from a given character set found in a given range with
given options.</p>
</div>
</div>
<div class="declaration" id="func-rangeOfComposedCharacterSequenceAtIndex">
<code class="language-swift">func rangeOfComposedCharacterSequenceAtIndex(anIndex: Index) -> Range&lt;Index&gt;</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns the range in the <code>String</code> of the composed
character sequence located at a given index.</p>
</div>
</div>
<div class="declaration" id="func-rangeOfComposedCharacterSequencesForRange">
<code class="language-swift">func rangeOfComposedCharacterSequencesForRange(range: Range&lt;Index&gt;) -> Range&lt;Index&gt;</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns the range in the string of the composed character
sequences for a given range.</p>
</div>
</div>
<div class="declaration" id="func-rangeOfString">
<code class="language-swift">func rangeOfString(aString: String, options mask: NSStringCompareOptions = default, range searchRange: Range&lt;Index&gt;? = default, locale: NSLocale? = default) -> Range&lt;Index&gt;?</code>
<div class="comment">
    <p><em>[Foundation]</em> Finds and returns the range of the first occurrence of a
given string within a given range of the <code>String</code>, subject to
given options, using the specified locale, if any.</p>
</div>
</div>
<div class="declaration" id="func-localizedStandardContainsString">
<code class="language-swift">func localizedStandardContainsString(string: String) -> Bool</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns <code>true</code> if <code>self</code> contains <code>string</code>, taking the current locale
into account.</p>

<p>This is the most appropriate method for doing user-level string searches,
similar to how searches are done generally in the system.  The search is
locale-aware, case and diacritic insensitive.  The exact list of search
options applied may change over time.</p>
</div>
</div>
<div class="declaration" id="func-localizedStandardRangeOfString">
<code class="language-swift">func localizedStandardRangeOfString(string: String) -> Range&lt;Index&gt;?</code>
<div class="comment">
    <p><em>[Foundation]</em> Finds and returns the range of the first occurrence of a given string,
taking the current locale into account.  Returns <code>nil</code> if the string was
not found.</p>

<p>This is the most appropriate method for doing user-level string searches,
similar to how searches are done generally in the system.  The search is
locale-aware, case and diacritic insensitive.  The exact list of search
options applied may change over time.</p>
</div>
</div>
<div class="declaration" id="func-stringByAddingPercentEncodingWithAllowedCharacters">
<code class="language-swift">func stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacters: NSCharacterSet) -> String?</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a new string made from the <code>String</code> by replacing
all characters not in the specified set with percent encoded
characters.</p>
</div>
</div>
<div class="declaration" id="func-stringByAddingPercentEscapesUsingEncoding">
<code class="language-swift">func stringByAddingPercentEscapesUsingEncoding(encoding: NSStringEncoding) -> String?</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a representation of the <code>String</code> using a given
encoding to determine the percent escapes necessary to convert
the <code>String</code> into a legal URL string.</p>
</div>
</div>
<div class="declaration" id="func-stringByAppendingFormat">
<code class="language-swift">func stringByAppendingFormat(format: String, _ arguments: CVarArgType...) -> String</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a string made by appending to the <code>String</code> a
string constructed from a given format string and the following
arguments.</p>
</div>
</div>
<div class="declaration" id="func-stringByAppendingString">
<code class="language-swift">func stringByAppendingString(aString: String) -> String</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a new string made by appending a given string to
the <code>String</code>.</p>
</div>
</div>
<div class="declaration" id="func-stringByFoldingWithOptions">
<code class="language-swift">func stringByFoldingWithOptions(options: NSStringCompareOptions, locale: NSLocale?) -> String</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a string with the given character folding options
applied.</p>
</div>
</div>
<div class="declaration" id="func-stringByPaddingToLength">
<code class="language-swift">func stringByPaddingToLength(newLength: Int, withString padString: String, startingAtIndex padIndex: Int) -> String</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a new string formed from the <code>String</code> by either
removing characters from the end, or by appending as many
occurrences as necessary of a given pad string.</p>
</div>
</div>
<div class="declaration" id="func-stringByReplacingCharactersInRange">
<code class="language-swift">func stringByReplacingCharactersInRange(range: Range&lt;Index&gt;, withString replacement: String) -> String</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a new string in which the characters in a
specified range of the <code>String</code> are replaced by a given string.</p>
</div>
</div>
<div class="declaration" id="func-stringByReplacingOccurrencesOfString">
<code class="language-swift">func stringByReplacingOccurrencesOfString(target: String, withString replacement: String, options: NSStringCompareOptions = default, range searchRange: Range&lt;Index&gt;? = default) -> String</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a new string in which all occurrences of a target
string in a specified range of the <code>String</code> are replaced by
another given string.</p>
</div>
</div>
<div class="declaration" id="func-stringByReplacingPercentEscapesUsingEncoding">
<code class="language-swift">func stringByReplacingPercentEscapesUsingEncoding(encoding: NSStringEncoding) -> String?</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a new string made by replacing in the <code>String</code>
all percent escapes with the matching characters as determined
by a given encoding.</p>
</div>
</div>
<div class="declaration" id="func-stringByTrimmingCharactersInSet">
<code class="language-swift">func stringByTrimmingCharactersInSet(set: NSCharacterSet) -> String</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a new string made by removing from both ends of
the <code>String</code> characters contained in a given character set.</p>
</div>
</div>
<div class="declaration" id="func-substringFromIndex">
<code class="language-swift">func substringFromIndex(index: Index) -> String</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a new string containing the characters of the
<code>String</code> from the one at a given index to the end.</p>
</div>
</div>
<div class="declaration" id="func-substringToIndex">
<code class="language-swift">func substringToIndex(index: Index) -> String</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a new string containing the characters of the
<code>String</code> up to, but not including, the one at a given index.</p>
</div>
</div>
<div class="declaration" id="func-substringWithRange">
<code class="language-swift">func substringWithRange(aRange: Range&lt;Index&gt;) -> String</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a string object containing the characters of the
<code>String</code> that lie within a given range.</p>
</div>
</div>
<div class="declaration" id="func-uppercaseStringWithLocale">
<code class="language-swift">func uppercaseStringWithLocale(locale: NSLocale?) -> String</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns a version of the string with all letters
converted to uppercase, taking into account the specified
locale.</p>
</div>
</div>
<div class="declaration" id="func-writeToFile">
<code class="language-swift">func writeToFile(path: String, atomically useAuxiliaryFile: Bool, encoding enc: NSStringEncoding) throws </code>
<div class="comment">
    <p><em>[Foundation]</em> Writes the contents of the <code>String</code> to a file at a given
path using a given encoding.</p>
</div>
</div>
<div class="declaration" id="func-writeToURL">
<code class="language-swift">func writeToURL(url: NSURL, atomically useAuxiliaryFile: Bool, encoding enc: NSStringEncoding) throws </code>
<div class="comment">
    <p><em>[Foundation]</em> Writes the contents of the <code>String</code> to the URL specified
by url using the specified encoding.</p>
</div>
</div>
<div class="declaration" id="func-stringByApplyingTransform">
<code class="language-swift">func stringByApplyingTransform(transform: String, reverse: Bool) -> String?</code>
<div class="comment">
    <p><em>[Foundation]</em> Perform string transliteration.</p>
</div>
</div>
<div class="declaration" id="func-containsString">
<code class="language-swift">func containsString(other: String) -> Bool</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns <code>true</code> iff <code>other</code> is non-empty and contained within
<code>self</code> by case-sensitive, non-literal search.</p>

<p>Equivalent to <code>self.rangeOfString(other) != nil</code></p>
</div>
</div>
<div class="declaration" id="func-localizedCaseInsensitiveContainsString">
<code class="language-swift">func localizedCaseInsensitiveContainsString(other: String) -> Bool</code>
<div class="comment">
    <p><em>[Foundation]</em> Returns <code>true</code> iff <code>other</code> is non-empty and contained within
<code>self</code> by case-insensitive, non-literal search, taking into
account the current locale.</p>

<p>Locale-independent case-insensitive operation, and other needs,
can be achieved by calling
<code>rangeOfString(_:options:,range:_locale:_)</code>.</p>

<p>Equivalent to</p>

<pre><code class="language-swift">self.rangeOfString(
  other, options: .CaseInsensitiveSearch,
  locale: NSLocale.currentLocale()) != nil</code></pre>
</div>
</div>

<h3>Subscripts</h3>
<div class="declaration">
<code class="language-swift">subscript(i: Index) -> Character { get }</code>
</div>
<div class="declaration">
<code class="language-swift">subscript(subRange: Range&lt;Index&gt;) -> String { get }</code>
</div>



          </article>

    
        </div><!-- content -->
      </div><!-- row -->
    </div><!-- cont -->
        <div class="push"></div>
    </div><!-- wrapper -->

            <div id="footer">
            <span class="line">
                <span class="version">Swift versions 602.0.49.3 & 700.0.59</span> &nbsp;&sdot;&nbsp;
                <a href="/news/">News</a>
            </span> <span class="sep">&nbsp;&sdot;&nbsp;</span>
            <span class="line">
                <a href="https://twitter.com/SwiftDocOrg">@SwiftDocOrg</a> &nbsp;&sdot;&nbsp;
                <a href="https://github.com/SwiftDocOrg">github.com/SwiftDocOrg</a>
            </span>
        </div>
        
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-58091972-1', 'auto');
  ga('send', 'pageview');
</script>

  
  </body>
</html>
